---
title: "Statistical Trending on Medical Device Surveillance Data"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Medical Device Surveillance Statistical Trending}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
load(file="../data/mds_ts.rda")
library(mdsstat)
```

The `mdsstat` package:

- Standardizes the output of various statistical trending algorithms
- Allows running of multiple algorithms on the same data
- Allows running of both **disproportionality** and **quality control** algorithms
- Creates lightweight analysis definitions and output files for auditability, documentation, and reproducibility

**Why?**

There are many ways to trend medical device event data. Some are drawn from the [quality control](https://en.wikipedia.org/wiki/Quality_control) discipline, others from disproportionality analysis used in pharmacoepidemiology, and yet others from the general field of statistics.

There is a need to rigorously compare and contrast these various methods to more fully understand their respective performance and applicability in surveillance of medical devices. To date, published literature and regulatory guidelines lack comprehensive reviews or clear directions on the statistics of medical device surveillance.

**How?**

The `mdsstat` package aims to provide a collection of statistical trending algorithms used in medical device surveillance. Furthermore, each algorithm is written with a standardized, reusable framework philosophy. The same input data can be fed through multiple algorithms. All algorithms return **results that can be sorted, stacked, and compared.**

This package is written in tandem with the `mds` package. These are complementary in the sense that:

- `mds` standardizes medical device event data.
- `mdsstat` standardizes the statistical trending of medical device event data.

While `mdsstat` algorithms can run on generic R data frames, additional efficiency and traceability benefits are derived by running on data frames generated by `mds::time_series()` from the `mds` package.

**Purpose of This Vignette**

- Introduce [the algorithms](#algos)
- Show how to [run one algorithm](#onealgo)
- Show how to run [multiple algorithms](#mutlialgo)

## Data: MAUDE Time Series Generated from `mds::time_series()`

The following examples use a sample list of three time series generated by `mds::time_series()` from the `mds` package, saved as `mds_ts` in this package. The underlying datat were queried from the [FDA MAUDE API](https://open.fda.gov/api/). Furthermore, a simulated exposure dataset `sales` was generated to provide exposure data.

```{r}
library(mdsstat)
data(mds_ts)
```


## The Algorithms {#algos}

This is the current list of algorithms available:

Function            Description
-----------------   ------------------------------------------------------------
`shewhart()`        Shewhart x-bar Control Chart with 4 Western Electric Rules
`prr()`             Proportional Reporting Ratio
`poisson_rare()`    Poisson Test on Rare Events

These are planned/proposed algorithms to add:

Function            Description
-----------------   ------------------------------------------------------------
`ebgm()`            Empirical Bayes Geometric Mean (basis of the Gamma Poisson Shrinker)
`bcpnn()`           Bayesian Confidence Propagation Neural Network
`ror()`             Reporting Odds Ratio
`chi_square()`      Chi-Square Test
`poisson_rare()`    Poisson Test on Rare Events
`changepoint()`     Binary Segmentation Changepoint
`cusum()`           Cumulative Sum Control Chart with 4 Western Electric Rules
`ewma()`            Exponentially Weighted Moving Average with 4 WE Rules
`cox_stuart()`      Cox-Stuart Test
`uptrend()`         Linear Uptrend by Linear Modeling


## Run One Algorithm {#onealgo}

In the simplest case, running an `mdsstat` algorithm requires two considerations:

1. Input data format (may be reused in other algorithms)
1. Algorithm parameter settings (unique to the algorithm)

The next section explains the various possible input data formats. Refer to each algorithm's documentation for their respective parameter settings.

Here are some example algorithm calls:

```{r}
data <- mds_ts[[3]]
data$rate <- ifelse(is.na(data$nA), 0, data$nA) / data$exposure
# Four different algorithm calls
shewhart(data)
prr(data)
shewhart(data, ts_event=c("Rate"="rate"), we_rule=2L)
poisson_rare(data, p_rate=0.3)
```

### Input Data Format

Input data shall be either a generic data frame (general usage) or an `mds_ts` data frame.

#### General Usage: Count or Rate Data

The most basic data frame contains two columns, `time` and `event`, structured conceptually as a time series where for each unique sequential time (numeric or Date), there corresponds a number indicating the event occurrence. The event occurrence may commonly be the count of events or event rate.

An example:

```{r}
data <- data.frame(time=c(1:25), event=as.integer(stats::rnorm(25, 100, 25)))
```

#### General Usage: Data for Disproportionality Analysis

Because disproportionality analysis (DPA) is run on count data in a 2x2 contingency table, this data frame requires five columns, `time`, `nA`, `nB`, `nC`, and `nD`. This is structured conceptually as a time series where for each unique sequential time (numeric or Date), there corresponds a set of numbers indicating the event counts. The latter four columns correspond to counts for cells A through D of the contingency table.

An example:

```{r}
data <- data.frame(time=c(1:25),
                   nA=as.integer(stats::rnorm(25, 25, 5)),
                   nB=as.integer(stats::rnorm(25, 50, 5)),
                   nC=as.integer(stats::rnorm(25, 100, 25)),
                   nD=as.integer(stats::rnorm(25, 200, 25)))
```

#### What if I want to do both?

Simple, just include all the above columns, such as:

```{r}
data <- data.frame(time=c(1:25),
                   event=as.integer(stats::rnorm(25, 100, 25)),
                   nA=as.integer(stats::rnorm(25, 25, 5)),
                   nB=as.integer(stats::rnorm(25, 50, 5)),
                   nC=as.integer(stats::rnorm(25, 100, 25)),
                   nD=as.integer(stats::rnorm(25, 200, 25)))
```

#### `mds_ts` Usage

`mds_ts` data frames are generated by `mds::time_series()` from the `mds` package. These data frames are already structured for seamless integration into `mdsstat` algorithms. Just note the following:

- Disproportionality algorithms will run only if the `mds_ts` data contains the columns `nA`, `nB`, `nC`, and `nD`. These are generated by specifying device and event hierarchies using `mds` package functions.
- Algorithms run by default using the `nA` column for event occurrence. If running on event rate is desired, you may calculate an additional field and specify that field using the `ts_event` parameter.

**How to run an algorithm on event rate instead of event count**

```{r}
data <- mds_ts[[3]]
data$rate <- ifelse(is.na(data$nA), 0, data$nA) / data$exposure
shewhart(data, ts_event=c("Rate"="rate"))
```


## Run Multiple Algorithms {#mutlialgo}
